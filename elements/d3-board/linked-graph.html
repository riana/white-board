<link rel="import" href="../../bower_components/polymer/polymer.html">



<style>
   .node-html {
      font-family: "Roboto";
      font-size: 14px;
      padding: 10px;
      box-sizing: border-box;
      cursor: pointer;
      font-weight: lighter;
   }

   .node-html-content {
      margin: 10px;
   }
</style>

<script type="text/javascript" src="../../bower_components/d3/d3.js"></script>

<script>
   const LinkedGraphStates = {
      IDLE: "IDLE",
      DRAGGING_ITEM: "DRAGGING_ITEM"

   }

   function getScreenCoords(x, y, translate, scale) {
      var xn = translate[0] + x * scale;
      var yn = translate[1] + y * scale;
      return {
         x: xn,
         y: yn
      };
   }

   function getDiagramCoords(x, y, translate, scale) {
      var xn = (x - translate[0]) / scale;
      var yn = (y - translate[1]) / scale;
      return {
         x: xn,
         y: yn
      };
   }


   if (typeof require === "function") {
      var d3 = require("d3");
   }

   class LinkedGraph {

      constructor(elSelector) {
         let width = 2048;
         let height = 2048;
         this.pencilFilter = false;
         var self = this;

         self.scale = 1;
         self.translate = [0, 0];

         function zoomed() {
            self.container.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
            self.scale = d3.event.scale;
            self.translate = d3.event.translate;
         }




         var zoom = d3.behavior.zoom()
            .scaleExtent([0.1, 1])
            .on("zoom", zoomed);

         this.svg = d3.select(elSelector).append("svg")
            .attr("width", width)
            .attr("height", height)
            .call(zoom)
            .on("mousedown", function(e) {
               this.touchStartDate = d3.event.timeStamp;
            })
            .on("mouseup", function(e) {
               let dt = d3.event.timeStamp - this.touchStartDate;


               var nodes = self.nodesLayer.selectAll(".node")[0];
               let pickedNodes = nodes.filter(node => {
                  let bbox = node.getBoundingClientRect();
                  let x = d3.event.clientX;
                  let y = d3.event.clientY;

                  let bbx = bbox.left;
                  let bby = bbox.top;
                  let inside = x > bbx && x < (bbx + bbox.width);
                  inside = inside && y > bby && y < (bby + bbox.height);
                  return inside;
               });
               if (dt < 50 && pickedNodes.length === 0) {
                  let coords = getDiagramCoords(d3.event.x, d3.event.y, self.translate, self.scale);
                  console.log('click on board : ', d3.event, coords);
                  self.onBoardClicked(d3.event, coords);
               }

               // console.log("touch end on board : ", dt);
            });

         var filter = this.svg.append("filter")
            .attr("id", "filter")
            // .attr("filterUnits", "userSpaceOnUse")
            // .attr("x", -5)
            // .attr("y", -5)
            .attr("height", 2000)
            .attr("width", 2000);

         filter.append("feTurbulence")
            .attr("baseFrequency", "0.2")
            .attr("numOctaves", "5")
            .attr("type", "fractalNoise");

         filter.append("feDisplacementMap")
            .attr("scale", "3")
            .attr("xChannelSelector", "R")
            .attr("in", "SourceGraphic");

         this.container = this.svg.append("g");


         this.linksLayer = this.container.append("g");
         this.nodesLayer = this.container.append("g");


         this.drag = d3.behavior.drag()
            .on("drag", function(d, i) {
               d.x += d3.event.dx;
               d.y += d3.event.dy;
               self.lastDrag = {
                  x: d3.event.x,
                  y: d3.event.y
               }

               self.updateGraph(self.data);
               if (self.onDragItem) {
                  let coords = getScreenCoords(d3.event.x, d3.event.y, self.translate, self.scale);
                  self.onDragItem(coords,
                     d);
               }
               d3.event.sourceEvent.stopPropagation();
            })
            .on('dragstart', function(d, i) {
               self.state = LinkedGraphStates.DRAGGING_ITEM;
               d3.event.sourceEvent.stopPropagation();
            })
            .on('dragend', function(d, i) {
               if (self.onDragItemEnd && self.lastDrag) {
                  let coords = getScreenCoords(self.lastDrag.x, self.lastDrag.y, self.translate, self.scale);
                  self.onDragItemEnd(coords,
                     d);
               }
               self.state = LinkedGraphStates.IDLE;
               // d3.event.stopPropagation();
               // console.log(d3.event);
               d3.event.sourceEvent.stopPropagation();

            });
         this.data = {}
      }

      updateEdges(data) {
         var link = this.linksLayer.selectAll("path")
            .data(data.links);
         link
            .enter().append("path")
            .attr("class", "link")
            .attr("stroke", "#000000")
            .attr("stroke-width", 2)
            .attr("fill", "none")
            .attr("style", () => {
               return this.pencilFilter ? "filter:url(#filter)" : "";
            });


         link.attr("d", function(d) {
            var target = data.nodes.filter((n) => {
               return n.id === d.target;
            })[0];
            var source = data.nodes.filter((n) => {
               return n.id === d.source;
            })[0];
            var dx = target.x - source.x,
               dy = target.y - source.y,
               dr = Math.sqrt(dx * dx + dy * dy);
            // Curved line
            // return "M" + source.x + "," + source.y + "A" + dr + "," + dr + " 0 0,1 " + target.x + "," + target.y;
            function rotate(cx, cy, x, y, angle) {
               var radians = (Math.PI / 180) * angle,
                  cos = Math.cos(radians),
                  sin = Math.sin(radians),
                  nx = (cos * (x - cx)) + (sin * (y - cy)) + cx,
                  ny = (cos * (y - cy)) - (sin * (x - cx)) + cy;
               return [nx, ny];
            }
            var p2 = rotate(0, 0, dx, dy, 90);
            var scale = dr / 4;
            scale = scale * Math.sign(dy) / dr;
            if (dx < 0) {

            }
            return "M" + source.x + ',' + source.y + 'S' + (source.x + dx / 2 + p2[0] * scale) + "," + (source.y + dy / 2 + p2[1] * scale) + ',' + target.x + "," + target.y;

            // Straigth line
            // return "M" + source.x + ',' + source.y + 'L' + target.x + "," + target.y;
         });

         link.exit().remove();
      }

      updateNodes(data) {
         let self = this;
         var node = this.nodesLayer.selectAll(".node")
            .data(data.nodes);

         var nodeGroup = node.enter().append("g")
            .call(this.drag)
            .attr("class", "node").attr("style", () => {
               return this.pencilFilter ? "filter:url(#filter)" : "";
            });

         node.attr("transform", function(d) {
            return 'translate(' + [d.x, d.y] + ')';
         });

         node.exit().remove();

         nodeGroup.append("foreignObject")

         .attr("class", "node-fo")
            // .attr("width", 100)
            // .attr("height", 30)
            .append("xhtml:body")
            .append("div")
            .attr("draggable", true)
            // .attr("width", 100)
            // .attr("height", 30)
            .on('click', function(d) {
               if (self.onNodeClicked) {

                  let screenPos = getScreenCoords(d.x, d.y, self.translate, self.scale);
                  self.onNodeClicked(d, screenPos);
               }
               d3.event.preventDefault();
               d3.event.stopPropagation();
            })
            .attr("class", "node-html")
            .append("div")
            .attr("class", "node-html-content")
            .html(function(d) {
               return d.text;
            });

         node.select(".node-fo").each(function(d) {

            let container = d3.select(this);
            let content = d3.select(this).select(".node-html").each(function(d) {
               let bounds = this.getBoundingClientRect();
               let width = d.width ? d.width : 100;
               let height = d.height ? d.height : 100;

               container
                  .attr("width", width)
                  .attr("height", height)
                  .attr("transform", function(d) {
                     let bbox = this.getBBox()
                     return "translate(" + [-width / 2, -height / 2] + ")"
                  });

            });


         });

         function insertLinebreaks(d) {
            var el = d3.select(this);
            // var lineHeight = el[0][0].clientHeight;
            var words = d.text.split('\n');

            el.text('');

            for (var i = 0; i < words.length; i++) {
               var tspan = el.append('br').text(words[i]);
               // if (i > 0)
               //    tspan.attr('x', 0).attr('dy', lineHeight);
            }
         };


         node.select(".node-html").html(function(d) {
            var html = d.text.split("\n");
            return html.join("<br>");
         }).attr("updateStyle", function(d) {
            // insertLinebreaks(d);
            // this.classList.add("green-card");
            this.style.color = "#FFFFFF";
            this.style.background = "#0000FF";
            // this.style.width = '300px';
            // this.style.height = '70px';
         });
      }

      updateGraph(data) {
         let self = this;
         this.data = data;
         // console.log("updating :", data.nodes);
         this.updateEdges(data);
         this.updateNodes(data);
      }

   }
</script>
