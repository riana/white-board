<link rel="import" href="../../bower_components/polymer/polymer.html">

<script type="text/javascript" src="../../bower_components/d3/d3.js"></script>

<style>
   .node-html {
      font-size: 12px;
      padding: 10px;
      cursor: pointer;
   }
</style>

<script>
   const LinkedGraphStates = {
      IDLE: "IDLE",
      DRAGGING_ITEM: "DRAGGING_ITEM"

   }
   class LinkedGraph {

      constructor(elSelector) {
         let width = 2048;
         let height = 2048;
         this.pencilFilter = false;
         var self = this;

         this.svg = d3.select(elSelector).append("svg")
            .attr("width", width)
            .attr("height", height)
            .on("mousedown", function(e) {
               this.touchStartDate = d3.event.timeStamp;
            })
            .on("mouseup", function(e) {
               let dt = d3.event.timeStamp - this.touchStartDate;
               if (dt < 50) {
                  self.onBoardClicked(d3.event);
               }
               // console.log("touch end on board : ", dt);
            });

         var filter = this.svg.append("filter")
            .attr("id", "filter")
            // .attr("filterUnits", "userSpaceOnUse")
            // .attr("x", -5)
            // .attr("y", -5)
            .attr("height", 2000)
            .attr("width", 2000);

         filter.append("feTurbulence")
            .attr("baseFrequency", "0.2")
            .attr("numOctaves", "5")
            .attr("type", "fractalNoise");

         filter.append("feDisplacementMap")
            .attr("scale", "3")
            .attr("xChannelSelector", "R")
            .attr("in", "SourceGraphic");


         this.linksLayer = this.svg.append("g");
         this.nodesLayer = this.svg.append("g");


         this.drag = d3.behavior.drag()
            .on("drag", function(d, i) {
               d.x += d3.event.dx;
               d.y += d3.event.dy;
               self.lastDrag = {
                  x: d3.event.x,
                  y: d3.event.y
               }

               self.state = LinkedGraphStates.DRAGGING_ITEM;

               self.updateGraph(self.data);
               if (self.onDragItem) {
                  self.onDragItem({
                        x: d3.event.x,
                        y: d3.event.y
                     },
                     d);
               }
            })
            .on('dragend', function(d, i) {
               if (self.onDragItemEnd) {
                  self.onDragItemEnd(self.lastDrag,
                     d);
               }
               self.state = LinkedGraphStates.IDLE;
               // d3.event.stopPropagation();

            });
         this.data = {}
      }

      updateEdges(data) {
         var link = this.linksLayer.selectAll("path")
            .data(data.links);
         link
            .enter().append("path")
            .attr("class", "link")
            .attr("stroke", "#000000")
            .attr("stroke-width", 2)
            .attr("fill", "none")
            .attr("style", () => {
               return this.pencilFilter ? "filter:url(#filter)" : "";
            });


         link.attr("d", function(d) {
            var target = data.nodes.filter((n) => {
               return n.id === d.target;
            })[0];
            var source = data.nodes.filter((n) => {
               return n.id === d.source;
            })[0];
            var dx = target.x - source.x,
               dy = target.y - source.y,
               dr = Math.sqrt(dx * dx + dy * dy);
            // Curved line
            // return "M" + source.x + "," + source.y + "A" + dr + "," + dr + " 0 0,1 " + target.x + "," + target.y;
            function rotate(cx, cy, x, y, angle) {
               var radians = (Math.PI / 180) * angle,
                  cos = Math.cos(radians),
                  sin = Math.sin(radians),
                  nx = (cos * (x - cx)) + (sin * (y - cy)) + cx,
                  ny = (cos * (y - cy)) - (sin * (x - cx)) + cy;
               return [nx, ny];
            }
            var p2 = rotate(0, 0, dx, dy, 90);
            var scale = dr / 4;
            scale = scale * Math.sign(dy) / dr;
            if(dx < 0){
               
            }
            return "M" + source.x + ',' + source.y + 'S' + (source.x + dx / 2 + p2[0] * scale) + "," + (source.y + dy / 2 + p2[1] * scale) + ',' + target.x + "," + target.y;

            // Straigth line
            // return "M" + source.x + ',' + source.y + 'L' + target.x + "," + target.y;
         });

         link.exit().remove();
      }

      updateNodes(data) {
         let self = this;
         var node = this.nodesLayer.selectAll(".node")
            .data(data.nodes);

         var nodeGroup = node.enter().append("g")
            .call(this.drag)
            .attr("class", "node").attr("style", () => {
               return this.pencilFilter ? "filter:url(#filter)" : "";
            });

         node.attr("transform", function(d) {
            return 'translate(' + [d.x, d.y] + ')';
         });

         node.exit().remove();

         nodeGroup.append("foreignObject")

         .attr("class", "node-fo")
            .attr("width", 100)
            .attr("height", 30)
            .append("xhtml:body")

         .append("div")
            .attr("draggable", true)
            .attr("width", 100)
            .attr("height", 30)
            .on('click', function(d) {

               console.log('clicked on : ', d, this, d3.event);
               d3.event.preventDefault();
               d3.event.stopPropagation();
            })
            .on("mouseup", function(d) {
               if (self.state !== LinkedGraphStates.DRAGGING_ITEM) {
                  d3.event.preventDefault();
                  d3.event.stopPropagation();
               }

            })
            .attr("class", "node-html")
            .append("span")
            .html(function(d) {
               return d.text;
            });

         node.select(".node-fo").attr("transform", function(d) {
            let bbox = this.getBBox()
            return "translate(" + [-bbox.width / 2, -bbox.height / 2] + ")"
         });

         node.select(".node-html").text(function(d) {
            // console.log("updating text : ", d);
            return d.text;
         }).attr("updateStyle", function(d) {
            // this.classList.add("green-card");
            this.style.color = "#FFFFFF";
            this.style.background = "#0000FF";
            // this.style.width = '300px';
            // this.style.height = '70px';
         });
      }

      updateGraph(data) {
         let self = this;
         this.data = data;
         // console.log("updating :", data.nodes);
         this.updateEdges(data);
         this.updateNodes(data);
      }

   }
</script>
