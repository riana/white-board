<link rel="import" href="../../bower_components/polymer/polymer.html">



<style>
    .node-html {
        padding: 10px;
        font-family: "Roboto";
        font-size: 14px;
        cursor: pointer;
        box-sizing: border-box;
        font-weight: lighter;
    }

    .node-sticky {
        box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12), 0 3px 1px -2px rgba(0, 0, 0, 0.2);
    }

    .node-text {}
</style>

<script type="text/javascript" src="../../bower_components/d3/d3.js"></script>
<script type="text/javascript" src="../../bower_components/marked/marked.min.js"></script>

<link rel="stylesheet" title="Default" href="../../bower_components/highlightjs/styles/default.css">
<!-- <link rel="stylesheet" title="Default" href="../../bower_components/highlightjs/styles/dracula.css"> -->
<script type="text/javascript" src="../../bower_components/highlightjs/highlight.pack.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script>
    const LinkedGraphStates = {
        IDLE: "IDLE",
        DRAGGING_ITEM: "DRAGGING_ITEM"

    }

    function getScreenCoords(x, y, translate, scale) {
        var xn = translate[0] + x * scale;
        var yn = translate[1] + y * scale;
        return {
            x: xn,
            y: yn
        };
    }

    function getDiagramCoords(x, y, translate, scale) {
        var xn = (x - translate[0]) / scale;
        var yn = (y - translate[1]) / scale;
        return {
            x: xn,
            y: yn
        };
    }

    function rotate(cx, cy, x, y, angle) {
        var radians = (Math.PI / 180) * angle,
            cos = Math.cos(radians),
            sin = Math.sin(radians),
            nx = (cos * (x - cx)) + (sin * (y - cy)) + cx,
            ny = (cos * (y - cy)) - (sin * (x - cx)) + cy;
        return [nx, ny];
    }


    if (typeof require === "function") {
        var d3 = require("d3");
    }

    class LinkedGraph {



        constructor(elSelector) {
            this.state = LinkedGraphStates.IDLE;
            let width = 2048;
            let height = 2048;
            this.pencilFilter = false;
            var self = this;

            self.scale = 1;
            self.translate = [0, 0];

            function zoomed() {
                self.container.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
                self.scale = d3.event.scale;
                self.translate = d3.event.translate;
                if (self.onViewportChanged) {
                    self.onViewportChanged({
                        scale: self.scale,
                        translate: self.translate
                    });
                }
            }

            this.zoom = d3.behavior.zoom()
                .scaleExtent([0.1, 1.5])
                .on("zoom", zoomed);

            this.svg = d3.select(elSelector).append("svg")
            .attr("id", "SVGBoard")
                .attr("width", width)
                .attr("height", height)
                .call(this.zoom)
                .on("mousedown", function(e) {
                    this.touchStartDate = d3.event.timeStamp;
                })
                .on("mouseup", function(e) {
                    let dt = d3.event.timeStamp - this.touchStartDate;


                    var nodes = self.nodesLayer.selectAll(".node")[0];
                    let pickedNodes = nodes.filter(node => {
                        let bbox = node.getBoundingClientRect();
                        let x = d3.event.clientX;
                        let y = d3.event.clientY;

                        let bbx = bbox.left;
                        let bby = bbox.top;
                        let inside = x > bbx && x < (bbx + bbox.width);
                        inside = inside && y > bby && y < (bby + bbox.height);
                        return inside;
                    });
                    if (dt < 50 && pickedNodes.length === 0) {
                        let coords = getDiagramCoords(d3.event.x, d3.event.y, self.translate, self.scale);
                        console.log('click on board : ', d3.event, coords);
                        self.selectedImage = null;
                        self.updateImages(self.data);
                        self.onBoardClicked(d3.event, coords);
                    }

                    // console.log("touch end on board : ", dt);
                });

            var filter = this.svg.append("filter")
                .attr("id", "filter")
                // .attr("filterUnits", "userSpaceOnUse")
                // .attr("x", -5)
                // .attr("y", -5)
                .attr("height", 2000)
                .attr("width", 2000);

            filter.append("feTurbulence")
                .attr("baseFrequency", "0.2")
                .attr("numOctaves", "5")
                .attr("type", "fractalNoise");

            filter.append("feDisplacementMap")
                .attr("scale", "3")
                .attr("xChannelSelector", "R")
                .attr("in", "SourceGraphic");

            this.container = this.svg.append("g");


            this.linksLayer = this.container.append("g");
            this.nodesLayer = this.container.append("g");


            this.drag = d3.behavior.drag()
                .on("drag", function(d, i) {
                    d.x += d3.event.dx;
                    d.y += d3.event.dy;
                    self.lastDrag = {
                        x: d3.event.x,
                        y: d3.event.y
                    }

                    self.updateGraph(self.data);

                    if (self.onDragItem) {
                        let coords = getScreenCoords(d3.event.x, d3.event.y, self.translate, self.scale);
                        self.onDragItem(coords,
                            d);
                    }
                    d3.event.sourceEvent.stopPropagation();
                })
                .on('dragstart', function(d, i) {
                    setTimeout(() => {
                        self.state = LinkedGraphStates.DRAGGING_ITEM;
                    }, 300);
                    d3.event.sourceEvent.stopPropagation();
                })
                .on('dragend', function(d, i) {
                    if (self.onDragItemEnd && self.lastDrag) {
                        let coords = getScreenCoords(self.lastDrag.x, self.lastDrag.y, self.translate, self.scale);
                        self.onDragItemEnd(coords,
                            d);
                    }
                    setTimeout(() => {
                        self.state = LinkedGraphStates.IDLE;
                    }, 300);

                    // d3.event.stopPropagation();
                    // console.log(d3.event);
                    d3.event.sourceEvent.stopPropagation();

                });
            this.data = {}

            this.setupControlLayer();
        }

        getDiagramCoords(x, y) {
            return getDiagramCoords(x, y, this.translate, this.scale);
        }

        updateEdges(data) {
            var link = this.linksLayer.selectAll("path")
                .data(data.links);
            link
                .enter().append("path")
                .attr("class", "link")
                .attr("stroke", "#000000")
                .attr("stroke-width", 2)
                .attr("fill", "none")
                .attr("style", () => {
                    return this.pencilFilter ? "filter:url(#filter)" : "";
                });


            link.attr("d", function(d) {
                var target = data.nodes.filter((n) => {
                    return n.id === d.target;
                })[0];
                var source = data.nodes.filter((n) => {
                    return n.id === d.source;
                })[0];
                var dx = target.x - source.x,
                    dy = target.y - source.y,
                    dr = Math.sqrt(dx * dx + dy * dy);
                // Curved line
                // return "M" + source.x + "," + source.y + "A" + dr + "," + dr + " 0 0,1 " + target.x + "," + target.y;

                var p2 = rotate(0, 0, dx, dy, 90);
                var scale = dr / 4;
                scale = scale * Math.sign(dy) / dr;
                if (dx < 0) {

                }
                return "M" + source.x + ',' + source.y + 'S' + (source.x + dx / 2 + p2[0] * scale) + "," + (source.y + dy / 2 + p2[1] * scale) + ',' + target.x + "," + target.y;

                // Straigth line
                // return "M" + source.x + ',' + source.y + 'L' + target.x + "," + target.y;
            });

            link.exit().remove();
        }

        updateNodes(data) {
            let self = this;
            var node = this.nodesLayer.selectAll(".node")
                .data(data.nodes);

            var nodeGroup = node.enter().append("g")
                .call(this.drag)
                .attr("class", "node").attr("style", () => {
                    return this.pencilFilter ? "filter:url(#filter)" : "";
                });

            node.attr("transform", function(d) {
                return 'translate(' + [d.x, d.y] + ')';
            });

            node.exit().remove();

            nodeGroup.append("foreignObject")

            .attr("class", "node-fo")
                // .attr("width", 100)
                // .attr("height", 30)
                .append("xhtml:body")
                .append("div")
                .on('click', function(d) {
                    if (self.onNodeClicked && self.state === LinkedGraphStates.IDLE) {
                        let screenPos = getScreenCoords(d.x, d.y, self.translate, self.scale);
                        self.onNodeClicked(d, screenPos);
                    }
                    d3.event.preventDefault();
                    d3.event.stopPropagation();
                })
                .attr("class", function(d) {
                    // let container = d3.select(this);
                    // console.log(d, container);
                    let style = "node-sticky";
                    if (d.type === "text") {
                        style = "node-text";
                    }
                    return `node-html ${style}`;
                })
                .append("div")

            .html(function(d) {
                return d.text;
            });

            node.select(".node-fo").each(function(d) {

                let container = d3.select(this);
                let content = d3.select(this).select(".node-html").each(function(d) {
                    let bounds = this.getBoundingClientRect();
                    let width = d.width ? d.width : 100;
                    let height = d.height ? d.height : 100;
                    container
                        .attr("width", '' + width + 'px')
                        .attr("height", '' + height + 'px')
                        .attr("transform", function(d) {
                            let bbox = this.getBBox()
                            return "translate(" + [-width / 2, -height / 2] + ")"
                        });

                });

            });

            function insertLinebreaks(d) {
                var el = d3.select(this);
                // var lineHeight = el[0][0].clientHeight;
                var words = d.text.split('\n');

                el.text('');

                for (var i = 0; i < words.length; i++) {
                    var tspan = el.append('br').text(words[i]);
                    // if (i > 0)
                    //    tspan.attr('x', 0).attr('dy', lineHeight);
                }
            };


            node.select(".node-html").html(function(d) {
                //  var html = d.text.split("\n");
                //  return html.join("<br>");
                marked.setOptions({
                    highlight: function(code) {
                        return hljs.highlightAuto(code).value;
                    }
                });

                return marked(d.text, {
                    breaks: true,
                    sanitize: true
                });
            }).attr("updateStyle", function(d) {
                this.style.color = d.style ? d.style.color : "#000000";
                this.style.background = d.style ? d.style.background : "none";
            });
        }

        setData(data) {


            if (data.view) {
                let defaultView = {
                    translate: [0, 0],
                    zoom: 1
                }
                this.applyZoom(defaultView);
                this.animateViewport(data.view);
            }

            this.updateGraph(data);
            this.updateImages(data);
        }

        updateGraph(data) {
            this.data = data;
            this.updateEdges(data);
            this.updateNodes(data);
            this.updateImages(data);
        }

        animateViewport(view) {
            if (!isNaN(view.scale) && !isNaN(view.translate[0]) && !isNaN(view.translate[1])) {
                this.svg.transition()
                    .duration(1000)
                    .call(this.zoom.translate(view.translate).scale(view.scale).event);
            }
        }

        applyZoom(view) {
            if (!isNaN(view.scale) && !isNaN(view.translate[0]) && !isNaN(view.translate[1])) {
                this.scale = view.scale;
                this.translate = view.translate;
                this.zoom.translate(view.translate);
                this.zoom.scale(view.scale);
                this.container.attr("transform", "translate(" + view.translate + ")scale(" + view.scale + ")");
            }
        }

        setupControlLayer() {
            let resizeDrag = d3.behavior.drag()
                .on('dragstart', (d) => {
                    //   if (this.imageTest.selected) {
                    d3.event.sourceEvent.preventDefault();
                    d3.event.sourceEvent.stopPropagation();
                    //   }
                })
                .on('drag', (d) => {
                    if (this.selectedImage) {
                        // let dMove = (d3.event.dx * d3.event.dx) + (d3.event.dy * d3.event.dy);
                        // let diagonal = (this.imageTest.width * this.imageTest.width) + (this.imageTest.height * this.imageTest.height);
                        // let ratio = dMove / diagonal;
                        this.selectedImage.width += d3.event.dx;
                        this.selectedImage.height += d3.event.dy;
                        this.updateImages(this.data);
                        d3.event.sourceEvent.preventDefault();
                        d3.event.sourceEvent.stopPropagation();
                    }

                });

            let rotateDrag = d3.behavior.drag()
                .on('dragstart', (e) => {
                    //   if (this.imageTest.selected) {
                    d3.event.sourceEvent.preventDefault();
                    d3.event.sourceEvent.stopPropagation();
                    //   }
                })
                .on('drag', (e) => {
                    if (this.selectedImage) {
                        let amount = d3.event.dx / 10;
                        this.selectedImage.rotation -= amount;

                        this.updateImages(this.data);
                        d3.event.sourceEvent.preventDefault();
                        d3.event.sourceEvent.stopPropagation();
                    }

                });

            this.controlLayer = this.container.append("g");

            this.controlLayer.append("svg:rect")
                .attr("id", "imageRect")
                .attr("fill", "none")
                .attr("stroke", "#FF0000");

            this.controlLayer.append("svg:circle")
                .attr("id", "imageResize")
                .attr("fill", "#EE0000")
                .attr("stroke", "#FF0000")
                .attr('r', 10)
                .call(resizeDrag);


            this.controlLayer.append("svg:line")
                .attr("id", "rotateLine")
                .attr("stroke", "#FF0000");

            this.controlLayer.append("svg:circle")
                .attr("id", "rotateCircle")
                .attr("fill", "#EE0000")
                .attr("stroke", "#FF0000")
                .attr('r', 10)
                .call(rotateDrag);
        }

        updateImages(data) {
            let self = this;
            var imageNodes = this.nodesLayer.selectAll(".image-node")
                .data(data.images);
            imageNodes.exit().remove();
            imageNodes.enter().append("svg:image")
                .attr("class", "image-node")
                .call(this.drag)
                .on("click", (d) => {
                    if (this.selectedImage === d) {
                        this.selectedImage = null;
                    } else {
                        this.selectedImage = d;
                    }

                    this.updateImages(this.data);
                });

            function rotateTransform(d) {
                if (d) {
                    let rx = d.x + d.width / 2;
                    let ry = d.y + d.height / 2;
                    let rotateTransform = "rotate(" + d.rotation + " " + rx + " " + ry + ")";
                    return rotateTransform;
                }
                return "";
            }

            this.controlLayer.attr("visibility", (e) => {
                return this.selectedImage ? "visible" : "hidden";
            });

            this.nodesLayer.selectAll('.image-node')
                .attr("xlink:href", function(d) {
                    //FIXME Improve image fetching
                    //   if (self.medias && self.medias[d.id]) {
                    //       console.log("media found");
                    //   } else {
                    //       console.log("media not found");
                    //   }
                    return self.medias ? self.medias[d.id] : null;
                })
                .attr('x', function(d) {
                    return d.x;
                })
                .attr('y', function(d) {
                    return d.y;
                })
                .attr("height", function(d) {
                    return d.height;
                })
                .attr("width", function(d) {
                    return d.width;
                })
                .attr("transform", rotateTransform);

            this.controlLayer.selectAll("#imageRect")
                .attr("x", (d) => {
                    return this.selectedImage ? this.selectedImage.x - 2 : 0;
                })
                .attr("y", (d) => {
                    return this.selectedImage ? this.selectedImage.y - 2 : 0;
                })
                .attr("height", (d) => {
                    return this.selectedImage ? this.selectedImage.height + 4 : 0;
                })
                .attr("width", (d) => {
                    return this.selectedImage ? this.selectedImage.width + 4 : 0;
                })
                .attr("transform", rotateTransform);

            this.controlLayer.attr("transform", () => {
                if (this.selectedImage) {
                    return rotateTransform(this.selectedImage);
                }
                return '';
            });

            this.controlLayer.selectAll('#imageResize')
                .attr('cx', (d) => {
                    return this.selectedImage ? this.selectedImage.x + this.selectedImage.width + 4 : 0;
                })
                .attr('cy', (d) => {
                    return this.selectedImage ? this.selectedImage.y + this.selectedImage.height + 4 : 0;
                })

            let rotateHandleCenter = {
                x: this.selectedImage ? this.selectedImage.x + this.selectedImage.width / 2 : 0,
                y: this.selectedImage ? this.selectedImage.y + this.selectedImage.height : 0
            }

            this.controlLayer.selectAll('#rotateLine')
                .attr("x1", (d) => {
                    return rotateHandleCenter.x;
                })
                .attr("y1", (d) => {
                    return rotateHandleCenter.y;
                })
                .attr("x2", (d) => {
                    return rotateHandleCenter.x;
                })
                .attr("y2", (d) => {
                    return rotateHandleCenter.y + 40;
                })

            this.controlLayer.selectAll('#rotateCircle')
                .attr('cx', rotateHandleCenter.x)
                .attr('cy', rotateHandleCenter.y + 40)
        }

        addMedia(id, data) {
            if (!this.medias) {
                this.medias = [];
            }
            this.medias[id] = data;
        }

        removeMedia(media) {
            if (this.selectedImage === media) {
                this.selectedImage = null;
            }
            delete this.medias[media.id];
        }



    }
</script>
