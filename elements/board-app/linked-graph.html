<style>
    .node-html {
        padding: 10px;
        font-family: "Roboto";
        font-size: 14px;
        cursor: pointer;
        box-sizing: border-box;
        font-weight: lighter;
    }

    .node-sticky {
        box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12), 0 3px 1px -2px rgba(0, 0, 0, 0.2);
    }

    .node-text {}
</style>

<script type="text/javascript" src="../../bower_components/d3/d3.js"></script>
<script type="text/javascript" src="../../bower_components/marked/marked.min.js"></script>

<link rel="stylesheet" title="Default" href="../../bower_components/highlightjs/styles/default.css">
<!-- <link rel="stylesheet" title="Default" href="../../bower_components/highlightjs/styles/dracula.css"> -->
<script type="text/javascript" src="../../bower_components/highlightjs/highlight.pack.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script type="text/javascript" src="./graph/ReshapeController.js"></script>
<script type="text/javascript" src="./graph/NodesRenderer.js"></script>
<script type="text/javascript" src="./graph/ImagesRenderer.js"></script>
<script type="text/javascript" src="./graph/ZonesRenderer.js"></script>



<script>

   // Check states necessity
    const LinkedGraphStates = {
        IDLE: "IDLE",
        DRAGGING_ITEM: "DRAGGING_ITEM",
        DRAW_RECT: "DRAW_RECT"

    }

    function getScreenCoords(x, y, translate, scale) {
        var xn = translate[0] + x * scale;
        var yn = translate[1] + y * scale;
        return {
            x: xn,
            y: yn
        };
    }

    function getDiagramCoords(x, y, translate, scale) {
        var xn = (x - translate[0]) / scale;
        var yn = (y - translate[1]) / scale;
        return {
            x: xn,
            y: yn
        };
    }

    function rotate(cx, cy, x, y, angle) {
        var radians = (Math.PI / 180) * angle,
            cos = Math.cos(radians),
            sin = Math.sin(radians),
            nx = (cos * (x - cx)) + (sin * (y - cy)) + cx,
            ny = (cos * (y - cy)) - (sin * (x - cx)) + cy;
        return [nx, ny];
    }


    if (typeof require === "function") {
        var d3 = require("d3");
    }

    class LinkedGraph {

        constructor(elSelector) {
            this.state = LinkedGraphStates.IDLE;
            let width = 2048;
            let height = 2048;
            this.pencilFilter = false;
            var self = this;

            self.scale = 1;
            self.translate = [0, 0];

            function zoomed() {
                if (self.state === LinkedGraphStates.IDLE) {
                    self.container.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
                    self.scale = d3.event.scale;
                    self.translate = d3.event.translate;
                    if (self.onViewportChanged) {
                        self.onViewportChanged({
                            scale: self.scale,
                            translate: self.translate
                        });
                    }
                }
            }

            this.zoom = d3.behavior.zoom()
                .scaleExtent([0.1, 1.5])
                .on("zoom", zoomed);

            this.svg = d3.select(elSelector).append("svg")
                .attr("id", "SVGBoard")
                .attr("width", width)
                .attr("height", height)
                .call(this.zoom)
                .on("mousedown", function(e) {
                    this.touchStartDate = d3.event.timeStamp;
                })
                .on("mouseup", function(e) {
                    let dt = d3.event.timeStamp - this.touchStartDate;

                    // FIXME : Handle picking
                  //   var nodes = self.nodesLayer.selectAll(".node")[0];
                  //   let pickedNodes = nodes.filter(node => {
                  //       let bbox = node.getBoundingClientRect();
                  //       let x = d3.event.clientX;
                  //       let y = d3.event.clientY;
                    //
                  //       let bbx = bbox.left;
                  //       let bby = bbox.top;
                  //       let inside = x > bbx && x < (bbx + bbox.width);
                  //       inside = inside && y > bby && y < (bby + bbox.height);
                  //       return inside;
                  //   });

                    let pickedNodes = []

                    if (dt < 50 && pickedNodes.length === 0) {
                        let coords = getDiagramCoords(d3.event.x, d3.event.y, self.translate, self.scale);
                        console.log('click on board : ', d3.event, coords);
                        self.cancelReshape();
                        self.onBoardClicked(d3.event, coords);
                    }

                    // console.log("touch end on board : ", dt);
                });

            var filter = this.svg.append("filter")
                .attr("id", "filter")
                // .attr("filterUnits", "userSpaceOnUse")
                // .attr("x", -5)
                // .attr("y", -5)
                .attr("height", 2000)
                .attr("width", 2000);

            filter.append("feTurbulence")
                .attr("baseFrequency", "0.2")
                .attr("numOctaves", "5")
                .attr("type", "fractalNoise");

            filter.append("feDisplacementMap")
                .attr("scale", "3")
                .attr("xChannelSelector", "R")
                .attr("in", "SourceGraphic");

            this.container = this.svg.append("g");

            this.renderers = [];
            this.renderers.push(new ZonesRenderer(this));
            this.renderers.push(new NodesRenderer(this));
            this.renderers.push(new ImagesRenderer(this));



            this.reshapeController = new ReshapeController(this);
            this.renderers.push(this.reshapeController);

            this.drawDrag = d3.behavior.drag()
                .on('dragstart', (d, i) => {
                    if (this.state === LinkedGraphStates.DRAW_RECT) {
                        this.viewportBackup = {
                            scale: self.scale,
                            translate: self.translate
                        };

                        // TODO fix DRAW_RECT offset
                        let coords = getDiagramCoords(d3.event.sourceEvent.x, d3.event.sourceEvent.y, this.translate, this.scale);

                        this.drawingRect.x = coords.x;
                        this.drawingRect.y = coords.y;
                        this.drawingRect.width = 0;
                        this.drawingRect.height = 0;

                    }
                })
                .on('dragend', (d, i) => {
                    if (this.state === LinkedGraphStates.DRAW_RECT) {
                        this.applyZoom(this.viewportBackup);
                        this.exitDrawRectMode();
                    }
                })
                .on("drag", (d, i) => {
                    if (this.state === LinkedGraphStates.DRAW_RECT) {
                        this.drawingLayer.attr("visibility", "visible");
                        let coords = getScreenCoords(d3.event.dx, d3.event.dy, [0, 0], 1 / self.scale);
                        this.drawingRect.width += coords.x;
                        this.drawingRect.height += coords.y;

                        this.drawingRect.width = Math.max(this.drawingRect.width, 0);
                        this.drawingRect.height = Math.max(this.drawingRect.height, 0);
                        this.updateDrawingRect();
                    }
                });
            this.svg.call(this.drawDrag);

            this.drag = d3.behavior.drag()
                .on("drag", function(d, i) {
                    d.x += d3.event.dx;
                    d.y += d3.event.dy;
                    self.lastDrag = {
                        x: d3.event.x,
                        y: d3.event.y
                    }

                    self.updateGraph(self.data);

                    if (self.onDragItem) {
                        let coords = getScreenCoords(d3.event.x, d3.event.y, self.translate, self.scale);
                        self.onDragItem(coords,
                            d);
                    }
                    d3.event.sourceEvent.stopPropagation();
                })
                .on('dragstart', function(d, i) {
                    setTimeout(() => {
                        self.state = LinkedGraphStates.DRAGGING_ITEM;
                    }, 300);
                    d3.event.sourceEvent.stopPropagation();
                })
                .on('dragend', function(d, i) {
                    if (self.onDragItemEnd && self.lastDrag) {
                        let coords = getScreenCoords(self.lastDrag.x, self.lastDrag.y, self.translate, self.scale);
                        self.onDragItemEnd(coords,
                            d);
                    }
                    setTimeout(() => {
                        self.state = LinkedGraphStates.IDLE;
                    }, 300);

                    // d3.event.stopPropagation();
                    // console.log(d3.event);
                    d3.event.sourceEvent.stopPropagation();

                });
            this.data = {}
        }

        startReshape(item) {
            this.reshapeController.selectedImage = item;
            this.reshapeController.update(this.data);
        }

        cancelReshape() {
            this.reshapeController.selectedImage = null;
            this.redraw();
        }

        onItemClicked(d) {
            if (this.onNodeClicked && this.state === LinkedGraphStates.IDLE) {
                let screenPos = getScreenCoords(d.x, d.y, this.translate, this.scale);
                this.onNodeClicked(d, screenPos);
            }
            d3.event.preventDefault();
            d3.event.stopPropagation();
        }

        getDiagramCoords(x, y) {
            return getDiagramCoords(x, y, this.translate, this.scale);
        }

        setData(data) {
            //Backward comptaibility
            if (!data.zones) {
                data.zones = [];
            }

            if (data.view) {
                let defaultView = {
                    translate: [0, 0],
                    zoom: 1
                }
                this.applyZoom(defaultView);
                this.animateViewport(data.view);
            }

            this.updateGraph(data);
        }

        redraw() {
            this.updateGraph(this.data);
        }

        updateGraph(data) {
            this.data = data;
            this.renderers.forEach(renderer => {
                renderer.update(data);
            });
        }

        animateViewport(view) {
            if (!isNaN(view.scale) && !isNaN(view.translate[0]) && !isNaN(view.translate[1])) {
                this.svg.transition()
                    .duration(1000)
                    .call(this.zoom.translate(view.translate).scale(view.scale).event);
            }
        }

        applyZoom(view) {
            if (!isNaN(view.scale) && !isNaN(view.translate[0]) && !isNaN(view.translate[1])) {
                this.scale = view.scale;
                this.translate = view.translate;
                this.zoom.translate(view.translate);
                this.zoom.scale(view.scale);
                this.container.attr("transform", "translate(" + view.translate + ")scale(" + view.scale + ")");
            }
        }

        addMedia(id, data) {
            if (!this.medias) {
                this.medias = [];
            }
            this.medias[id] = data;
        }

        removeMedia(media) {
            if (this.selectedImage === media) {
                this.selectedImage = null;
            }
            delete this.medias[media.id];
        }

        enterDrawRectMode(onDrawRectComplete) {
            if (!this.drawingLayer) {
                this.drawingLayer = this.container.append("g");

                this.drawingLayer.append("svg:rect")
                    .attr("id", "drawingRect")
                    .attr("fill", "none")
                    .attr("stroke", "#FF0000")
                    .attr("stroke-width", "10px");

                this.drawingRect = {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                };
            }

            this.onDrawRectComplete = onDrawRectComplete;

            this.state = LinkedGraphStates.DRAW_RECT;
        }

        exitDrawRectMode() {
            this.state = LinkedGraphStates.IDLE;
            this.drawingLayer.attr("visibility", "hidden");
            if (this.onStateChanged) {
                this.onStateChanged(this.state);
            }

            if (this.onDrawRectComplete) {
                this.onDrawRectComplete(this.drawingRect);
            }
        }

        updateDrawingRect() {
            this.drawingLayer.selectAll("#drawingRect")
                .attr("x", (d) => {
                    return this.drawingRect.x;
                })
                .attr("y", (d) => {
                    return this.drawingRect.y;
                })
                .attr("height", (d) => {
                    return this.drawingRect.height;
                })
                .attr("width", (d) => {
                    return this.drawingRect.width;
                });
        }

    }
</script>
